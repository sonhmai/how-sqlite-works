use std::cell::RefCell;
use std::fs::File;
use std::io::Read;
use std::rc::Rc;

use anyhow::Result;

use crate::access::buffer_pool::BufferPool;
use crate::model::db_meta::DbMeta;
use crate::storage::default::DefaultDiskManager;

const MAGIC_HEADER: [u8; 16] = *b"SQLite format 3\0";
const ROOT_PAGE_OFFSET: u8 = 100;
const NUM_CELLS_OFFSET: u8 = 3;

/// A sqlite3 database (1 db file)
#[derive(Debug)]
pub struct Database {
    pub db_meta: DbMeta,
    pub buffer_pool: BufferPool,
}

impl Database {
    /// create a Database instance from file path
    pub fn new(file_path: &str) -> Result<Self> {
        // To get page_size we need to parse the first 100 bytes before
        // constructing BufferPool and DiskManager as they need those info.
        // Hence, DbMeta has the exception of access physical file directly,
        // not through BufferPool.
        let mut file = File::open(file_path)?;
        let mut buf: Vec<u8> = vec![];
        // TODO read only what we need not the whole file into mem.
        file.read_to_end(&mut buf)?;
        let db_meta = DbMeta::parse(buf.as_slice())?;

        let page_size = db_meta.db_header.page_size;
        let disk_manager = DefaultDiskManager::new(file_path, page_size as usize)?;
        let shared_dm = Rc::new(RefCell::new(disk_manager));
        // TODO does Database need ref to DiskManager? why?
        //  If yes, how to have both database and buffer pool refs 1 obj DiskManager?
        // ownership of disk_manager is moved to BufferPool
        let buffer_pool = BufferPool::new(10, shared_dm.clone());

        Ok(Database {
            db_meta,
            buffer_pool,
        })
    }
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use crate::model::database::Database;

    #[test]
    fn test_database() {
        let db_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/resources/sample.db");
        let db = Database::new(db_path.as_path().to_str().unwrap()).unwrap();

        assert_eq!(db.db_meta.db_header.page_size, 4096);
    }
}
